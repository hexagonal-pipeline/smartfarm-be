// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: raids.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRaid = `-- name: CreateRaid :one
INSERT INTO raids (title, description, crop_type, target_quantity, min_participation, max_participation, price_per_kg, deadline, creator_nickname)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, title, description, crop_type, target_quantity, min_participation, max_participation, price_per_kg, deadline, status, creator_nickname, created_at
`

type CreateRaidParams struct {
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	CropType         string           `json:"crop_type"`
	TargetQuantity   int32            `json:"target_quantity"`
	MinParticipation int32            `json:"min_participation"`
	MaxParticipation int32            `json:"max_participation"`
	PricePerKg       int32            `json:"price_per_kg"`
	Deadline         pgtype.Timestamp `json:"deadline"`
	CreatorNickname  string           `json:"creator_nickname"`
}

func (q *Queries) CreateRaid(ctx context.Context, arg CreateRaidParams) (Raid, error) {
	row := q.db.QueryRow(ctx, createRaid,
		arg.Title,
		arg.Description,
		arg.CropType,
		arg.TargetQuantity,
		arg.MinParticipation,
		arg.MaxParticipation,
		arg.PricePerKg,
		arg.Deadline,
		arg.CreatorNickname,
	)
	var i Raid
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CropType,
		&i.TargetQuantity,
		&i.MinParticipation,
		&i.MaxParticipation,
		&i.PricePerKg,
		&i.Deadline,
		&i.Status,
		&i.CreatorNickname,
		&i.CreatedAt,
	)
	return i, err
}

const getNicknameRaidHistory = `-- name: GetNicknameRaidHistory :many
SELECT rp.id, rp.raid_id, rp.participant_nickname, rp.quantity, rp.expected_revenue, rp.status, rp.created_at, r.title, r.crop_type, r.deadline, r.status as raid_status
FROM raid_participations rp
JOIN raids r ON rp.raid_id = r.id
WHERE rp.participant_nickname = $1
ORDER BY rp.created_at DESC
`

type GetNicknameRaidHistoryRow struct {
	ID                  int32            `json:"id"`
	RaidID              int32            `json:"raid_id"`
	ParticipantNickname string           `json:"participant_nickname"`
	Quantity            int32            `json:"quantity"`
	ExpectedRevenue     int32            `json:"expected_revenue"`
	Status              pgtype.Text      `json:"status"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	Title               string           `json:"title"`
	CropType            string           `json:"crop_type"`
	Deadline            pgtype.Timestamp `json:"deadline"`
	RaidStatus          pgtype.Text      `json:"raid_status"`
}

func (q *Queries) GetNicknameRaidHistory(ctx context.Context, participantNickname string) ([]GetNicknameRaidHistoryRow, error) {
	rows, err := q.db.Query(ctx, getNicknameRaidHistory, participantNickname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNicknameRaidHistoryRow{}
	for rows.Next() {
		var i GetNicknameRaidHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.RaidID,
			&i.ParticipantNickname,
			&i.Quantity,
			&i.ExpectedRevenue,
			&i.Status,
			&i.CreatedAt,
			&i.Title,
			&i.CropType,
			&i.Deadline,
			&i.RaidStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRaidDetails = `-- name: GetRaidDetails :one
SELECT r.id, r.title, r.description, r.crop_type, r.target_quantity, r.min_participation, r.max_participation, r.price_per_kg, r.deadline, r.status, r.creator_nickname, r.created_at,
       COALESCE(SUM(rp.quantity), 0) as current_quantity,
       COUNT(rp.id) as participant_count
FROM raids r
LEFT JOIN raid_participations rp ON r.id = rp.raid_id
WHERE r.id = $1
GROUP BY r.id
`

type GetRaidDetailsRow struct {
	ID               int32            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	CropType         string           `json:"crop_type"`
	TargetQuantity   int32            `json:"target_quantity"`
	MinParticipation int32            `json:"min_participation"`
	MaxParticipation int32            `json:"max_participation"`
	PricePerKg       int32            `json:"price_per_kg"`
	Deadline         pgtype.Timestamp `json:"deadline"`
	Status           pgtype.Text      `json:"status"`
	CreatorNickname  string           `json:"creator_nickname"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	CurrentQuantity  interface{}      `json:"current_quantity"`
	ParticipantCount int64            `json:"participant_count"`
}

func (q *Queries) GetRaidDetails(ctx context.Context, id int32) (GetRaidDetailsRow, error) {
	row := q.db.QueryRow(ctx, getRaidDetails, id)
	var i GetRaidDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CropType,
		&i.TargetQuantity,
		&i.MinParticipation,
		&i.MaxParticipation,
		&i.PricePerKg,
		&i.Deadline,
		&i.Status,
		&i.CreatorNickname,
		&i.CreatedAt,
		&i.CurrentQuantity,
		&i.ParticipantCount,
	)
	return i, err
}

const getRaidParticipations = `-- name: GetRaidParticipations :many
SELECT rp.id, rp.raid_id, rp.participant_nickname, rp.quantity, rp.expected_revenue, rp.status, rp.created_at, r.title as raid_title
FROM raid_participations rp
JOIN raids r ON rp.raid_id = r.id
WHERE rp.raid_id = $1
ORDER BY rp.created_at DESC
`

type GetRaidParticipationsRow struct {
	ID                  int32            `json:"id"`
	RaidID              int32            `json:"raid_id"`
	ParticipantNickname string           `json:"participant_nickname"`
	Quantity            int32            `json:"quantity"`
	ExpectedRevenue     int32            `json:"expected_revenue"`
	Status              pgtype.Text      `json:"status"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	RaidTitle           string           `json:"raid_title"`
}

func (q *Queries) GetRaidParticipations(ctx context.Context, raidID int32) ([]GetRaidParticipationsRow, error) {
	rows, err := q.db.Query(ctx, getRaidParticipations, raidID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRaidParticipationsRow{}
	for rows.Next() {
		var i GetRaidParticipationsRow
		if err := rows.Scan(
			&i.ID,
			&i.RaidID,
			&i.ParticipantNickname,
			&i.Quantity,
			&i.ExpectedRevenue,
			&i.Status,
			&i.CreatedAt,
			&i.RaidTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinRaid = `-- name: JoinRaid :one
INSERT INTO raid_participations (raid_id, participant_nickname, quantity, expected_revenue)
VALUES ($1, $2, $3, $4)
RETURNING id, raid_id, participant_nickname, quantity, expected_revenue, status, created_at
`

type JoinRaidParams struct {
	RaidID              int32  `json:"raid_id"`
	ParticipantNickname string `json:"participant_nickname"`
	Quantity            int32  `json:"quantity"`
	ExpectedRevenue     int32  `json:"expected_revenue"`
}

func (q *Queries) JoinRaid(ctx context.Context, arg JoinRaidParams) (RaidParticipation, error) {
	row := q.db.QueryRow(ctx, joinRaid,
		arg.RaidID,
		arg.ParticipantNickname,
		arg.Quantity,
		arg.ExpectedRevenue,
	)
	var i RaidParticipation
	err := row.Scan(
		&i.ID,
		&i.RaidID,
		&i.ParticipantNickname,
		&i.Quantity,
		&i.ExpectedRevenue,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listOpenRaids = `-- name: ListOpenRaids :many
SELECT r.id, r.title, r.description, r.crop_type, r.target_quantity, r.min_participation, r.max_participation, r.price_per_kg, r.deadline, r.status, r.creator_nickname, r.created_at,
       COALESCE(SUM(rp.quantity), 0) as current_quantity,
       COUNT(rp.id) as participant_count
FROM raids r
LEFT JOIN raid_participations rp ON r.id = rp.raid_id
WHERE r.status = 'open' AND r.deadline > NOW()
GROUP BY r.id
ORDER BY r.deadline ASC
`

type ListOpenRaidsRow struct {
	ID               int32            `json:"id"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	CropType         string           `json:"crop_type"`
	TargetQuantity   int32            `json:"target_quantity"`
	MinParticipation int32            `json:"min_participation"`
	MaxParticipation int32            `json:"max_participation"`
	PricePerKg       int32            `json:"price_per_kg"`
	Deadline         pgtype.Timestamp `json:"deadline"`
	Status           pgtype.Text      `json:"status"`
	CreatorNickname  string           `json:"creator_nickname"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	CurrentQuantity  interface{}      `json:"current_quantity"`
	ParticipantCount int64            `json:"participant_count"`
}

func (q *Queries) ListOpenRaids(ctx context.Context) ([]ListOpenRaidsRow, error) {
	rows, err := q.db.Query(ctx, listOpenRaids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOpenRaidsRow{}
	for rows.Next() {
		var i ListOpenRaidsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CropType,
			&i.TargetQuantity,
			&i.MinParticipation,
			&i.MaxParticipation,
			&i.PricePerKg,
			&i.Deadline,
			&i.Status,
			&i.CreatorNickname,
			&i.CreatedAt,
			&i.CurrentQuantity,
			&i.ParticipantCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRaidStatus = `-- name: UpdateRaidStatus :one
UPDATE raids
SET status = $2
WHERE id = $1
RETURNING id, title, description, crop_type, target_quantity, min_participation, max_participation, price_per_kg, deadline, status, creator_nickname, created_at
`

type UpdateRaidStatusParams struct {
	ID     int32       `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateRaidStatus(ctx context.Context, arg UpdateRaidStatusParams) (Raid, error) {
	row := q.db.QueryRow(ctx, updateRaidStatus, arg.ID, arg.Status)
	var i Raid
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CropType,
		&i.TargetQuantity,
		&i.MinParticipation,
		&i.MaxParticipation,
		&i.PricePerKg,
		&i.Deadline,
		&i.Status,
		&i.CreatorNickname,
		&i.CreatedAt,
	)
	return i, err
}
