// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: gamification.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUserStats = `-- name: CreateUserStats :one
INSERT INTO user_stats (nickname)
VALUES ($1)
RETURNING nickname, level, experience, total_revenue, successful_raids, plots_rented, updated_at
`

func (q *Queries) CreateUserStats(ctx context.Context, nickname string) (UserStat, error) {
	row := q.db.QueryRow(ctx, createUserStats, nickname)
	var i UserStat
	err := row.Scan(
		&i.Nickname,
		&i.Level,
		&i.Experience,
		&i.TotalRevenue,
		&i.SuccessfulRaids,
		&i.PlotsRented,
		&i.UpdatedAt,
	)
	return i, err
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT nickname, level, experience, total_revenue, successful_raids
FROM user_stats
ORDER BY total_revenue DESC, level DESC
LIMIT 10
`

type GetLeaderboardRow struct {
	Nickname        string      `json:"nickname"`
	Level           pgtype.Int4 `json:"level"`
	Experience      pgtype.Int4 `json:"experience"`
	TotalRevenue    pgtype.Int4 `json:"total_revenue"`
	SuccessfulRaids pgtype.Int4 `json:"successful_raids"`
}

func (q *Queries) GetLeaderboard(ctx context.Context) ([]GetLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLeaderboardRow{}
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(
			&i.Nickname,
			&i.Level,
			&i.Experience,
			&i.TotalRevenue,
			&i.SuccessfulRaids,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
SELECT nickname, level, experience, total_revenue, successful_raids, plots_rented, updated_at FROM user_stats
WHERE nickname = $1
`

func (q *Queries) GetUserStats(ctx context.Context, nickname string) (UserStat, error) {
	row := q.db.QueryRow(ctx, getUserStats, nickname)
	var i UserStat
	err := row.Scan(
		&i.Nickname,
		&i.Level,
		&i.Experience,
		&i.TotalRevenue,
		&i.SuccessfulRaids,
		&i.PlotsRented,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementSuccessfulRaids = `-- name: IncrementSuccessfulRaids :one
UPDATE user_stats
SET successful_raids = successful_raids + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE nickname = $1
RETURNING nickname, level, experience, total_revenue, successful_raids, plots_rented, updated_at
`

func (q *Queries) IncrementSuccessfulRaids(ctx context.Context, nickname string) (UserStat, error) {
	row := q.db.QueryRow(ctx, incrementSuccessfulRaids, nickname)
	var i UserStat
	err := row.Scan(
		&i.Nickname,
		&i.Level,
		&i.Experience,
		&i.TotalRevenue,
		&i.SuccessfulRaids,
		&i.PlotsRented,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserExperience = `-- name: UpdateUserExperience :one
UPDATE user_stats
SET experience = experience + $2,
    level = CASE 
        WHEN (experience + $2) >= level * 100 THEN level + 1
        ELSE level
    END,
    updated_at = CURRENT_TIMESTAMP
WHERE nickname = $1
RETURNING nickname, level, experience, total_revenue, successful_raids, plots_rented, updated_at
`

type UpdateUserExperienceParams struct {
	Nickname   string      `json:"nickname"`
	Experience pgtype.Int4 `json:"experience"`
}

func (q *Queries) UpdateUserExperience(ctx context.Context, arg UpdateUserExperienceParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, updateUserExperience, arg.Nickname, arg.Experience)
	var i UserStat
	err := row.Scan(
		&i.Nickname,
		&i.Level,
		&i.Experience,
		&i.TotalRevenue,
		&i.SuccessfulRaids,
		&i.PlotsRented,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRevenue = `-- name: UpdateUserRevenue :one
UPDATE user_stats
SET total_revenue = total_revenue + $2,
    updated_at = CURRENT_TIMESTAMP
WHERE nickname = $1
RETURNING nickname, level, experience, total_revenue, successful_raids, plots_rented, updated_at
`

type UpdateUserRevenueParams struct {
	Nickname     string      `json:"nickname"`
	TotalRevenue pgtype.Int4 `json:"total_revenue"`
}

func (q *Queries) UpdateUserRevenue(ctx context.Context, arg UpdateUserRevenueParams) (UserStat, error) {
	row := q.db.QueryRow(ctx, updateUserRevenue, arg.Nickname, arg.TotalRevenue)
	var i UserStat
	err := row.Scan(
		&i.Nickname,
		&i.Level,
		&i.Experience,
		&i.TotalRevenue,
		&i.SuccessfulRaids,
		&i.PlotsRented,
		&i.UpdatedAt,
	)
	return i, err
}
