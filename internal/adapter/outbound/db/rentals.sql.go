// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rentals.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRental = `-- name: CreateRental :one
INSERT INTO rentals (renter_nickname, plot_id, start_date, end_date, monthly_rent)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, renter_nickname, plot_id, start_date, end_date, monthly_rent, status, created_at
`

type CreateRentalParams struct {
	RenterNickname string      `json:"renter_nickname"`
	PlotID         pgtype.Int4 `json:"plot_id"`
	StartDate      pgtype.Date `json:"start_date"`
	EndDate        pgtype.Date `json:"end_date"`
	MonthlyRent    int32       `json:"monthly_rent"`
}

func (q *Queries) CreateRental(ctx context.Context, arg CreateRentalParams) (Rental, error) {
	row := q.db.QueryRow(ctx, createRental,
		arg.RenterNickname,
		arg.PlotID,
		arg.StartDate,
		arg.EndDate,
		arg.MonthlyRent,
	)
	var i Rental
	err := row.Scan(
		&i.ID,
		&i.RenterNickname,
		&i.PlotID,
		&i.StartDate,
		&i.EndDate,
		&i.MonthlyRent,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getNicknameRentals = `-- name: GetNicknameRentals :many
SELECT r.id, r.renter_nickname, r.plot_id, r.start_date, r.end_date, r.monthly_rent, r.status, r.created_at, fp.name as plot_name, fp.location, fp.crop_type, fp.size_sqm
FROM rentals r
JOIN farm_plots fp ON r.plot_id = fp.id
WHERE r.renter_nickname = $1 AND r.status = 'active'
ORDER BY r.start_date DESC
`

type GetNicknameRentalsRow struct {
	ID             int32            `json:"id"`
	RenterNickname string           `json:"renter_nickname"`
	PlotID         pgtype.Int4      `json:"plot_id"`
	StartDate      pgtype.Date      `json:"start_date"`
	EndDate        pgtype.Date      `json:"end_date"`
	MonthlyRent    int32            `json:"monthly_rent"`
	Status         pgtype.Text      `json:"status"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	PlotName       string           `json:"plot_name"`
	Location       pgtype.Text      `json:"location"`
	CropType       pgtype.Text      `json:"crop_type"`
	SizeSqm        int32            `json:"size_sqm"`
}

func (q *Queries) GetNicknameRentals(ctx context.Context, renterNickname string) ([]GetNicknameRentalsRow, error) {
	rows, err := q.db.Query(ctx, getNicknameRentals, renterNickname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNicknameRentalsRow{}
	for rows.Next() {
		var i GetNicknameRentalsRow
		if err := rows.Scan(
			&i.ID,
			&i.RenterNickname,
			&i.PlotID,
			&i.StartDate,
			&i.EndDate,
			&i.MonthlyRent,
			&i.Status,
			&i.CreatedAt,
			&i.PlotName,
			&i.Location,
			&i.CropType,
			&i.SizeSqm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRental = `-- name: GetRental :one
SELECT r.id, r.renter_nickname, r.plot_id, r.start_date, r.end_date, r.monthly_rent, r.status, r.created_at, fp.name as plot_name, fp.location, fp.crop_type, fp.size_sqm
FROM rentals r
JOIN farm_plots fp ON r.plot_id = fp.id
WHERE r.id = $1
`

type GetRentalRow struct {
	ID             int32            `json:"id"`
	RenterNickname string           `json:"renter_nickname"`
	PlotID         pgtype.Int4      `json:"plot_id"`
	StartDate      pgtype.Date      `json:"start_date"`
	EndDate        pgtype.Date      `json:"end_date"`
	MonthlyRent    int32            `json:"monthly_rent"`
	Status         pgtype.Text      `json:"status"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	PlotName       string           `json:"plot_name"`
	Location       pgtype.Text      `json:"location"`
	CropType       pgtype.Text      `json:"crop_type"`
	SizeSqm        int32            `json:"size_sqm"`
}

func (q *Queries) GetRental(ctx context.Context, id int32) (GetRentalRow, error) {
	row := q.db.QueryRow(ctx, getRental, id)
	var i GetRentalRow
	err := row.Scan(
		&i.ID,
		&i.RenterNickname,
		&i.PlotID,
		&i.StartDate,
		&i.EndDate,
		&i.MonthlyRent,
		&i.Status,
		&i.CreatedAt,
		&i.PlotName,
		&i.Location,
		&i.CropType,
		&i.SizeSqm,
	)
	return i, err
}
